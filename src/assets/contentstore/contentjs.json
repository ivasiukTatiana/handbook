{
  "contentjs": [
    {
      "id": "js0",
      "href": "js#js0",
      "title": "JavaScript - що це і для чого",
      "article": "<p><b>JavaScript</b> - динамічна, об'єктно-орієнтована мова програмування. HTML - це розмітка (або інакше - структура сайту), CSS - зовнішній вигляд цієї розмітки. А JavaScript дозволяє створювати саме програми, які здатні заставити комп'ютер користувача виконувати активні дії. З допомогою JavaScript web-сторінкам надається інтерактивність.<br>JavaScript - мова сценаріїв, або скриптів. <b>Скрипт</b> являє собою програмний код - набір інструкцій, який не вимагає попередньої обробки (наприклад, компіляції) перед запуском. Для виконання скрипта потрібна  спеціальна програма - <b>інтерпретатор</b>. Процес виконання скрипта називають <b>інтерпретацією</b>. В усі сучасні браузери вбудований інтерпретатор JavaScript, саме тому вони можуть виконувати скрипти на сторінці. Інтерпретатор браузера виконує аналіз і обробку скрипта і, як тільки завантажується сторінка, – одразу виконує його.<br>JavaScript можна використовувати не тільки в браузері. Це повноцінна мова, програми на якій можна запускати і на сервері.<br>У браузері <b>JavaScript</b> вміє робити все, що відноситься до маніпуляції зі сторінкою, взаємодії з відвідувачем і, в якійсь мірі, з сервером:<br>&#10004; Створювати нові HTML-теги, видаляти існуючі, змінювати стилі елементів, ховати, показувати елементи і т.п.<br>&#10004; Реагувати на дії відвідувача, обробляти кліки миші, переміщення курсору, натискання на клавіатуру і т.п.<br>&#10004; Перевіряти дані, введені в поля форми, перш ніж вони будуть передані на сервер, що запобігає зайвій обробці на сервері<br>&#10004; Посилати запити на сервер і завантажувати дані без перезавантаження сторінки (ця технологія називається \"AJAX\")<br>&#10004; Запитувати дані, виводити повідомлення<br>&#10004; Визначити браузер користувача і, - в залежності від нього, - завантажувати сторінку, спроектовану спеціально для цього браузера і багато іншого...</p>"
    },
    {
      "id": "js1",
      "href": "js#js1",
      "title": "Підключення сценаріїв до HTML-документа",
      "article": "<p>Сценарії JavaScript бувають <b>вбудовані</b>, тобто їх вміст є частиною документа, і <b>зовнішні</b>, що зберігаються в окремому файлі з розширенням <b>.js</b>.<br>Сценарії можна підключити до  HTML-документа наступними способами:</p><p>&bull; У вигляді гіперпосилання. Для цього потрібно розмістити код в окремому файлі і включити посилання на файл в заголовок:</p><pre><code>&lt;head&gt;\n  &lt;script <span class=\"color-red\">type</span>=\"text/javascript\" <span class=\"color-red\">src</span>=\"js/script.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;</code></pre><p>або тіло сторінки:</p><pre><code>&lt;body&gt;\n  &lt;script <span class=\"color-red\">type</span>=\"text/javascript\" <span class=\"color-red\">src</span>=\"js/script.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;</code></pre><p>Цей спосіб зазвичай застосовується для сценаріїв великого розміру або сценаріїв, які багаторазово використовуються на різних веб-сторінках.</p><p>&bull; Всередину елемента <b>&lt;script&gt; &lt;/script&gt;</b>. Елемент &lt;script&gt; може бути розміщений в будь-якому місці документа. Усередині тега розташовується код, який виконується відразу після загрузки браузером. Зазвичай код JavaScript розміщується в заголовку документа (елемент &lt;head&gt;) або після відкриваючого тега &lt;body&gt;</p><pre><code>&lt;script <span class=\"color-red\">type</span>=\"text/javascript\"&gt;\n  alert('Hello, World!');\n&lt;/script&gt;</code></pre><p>&bull; У вигляді <b>обробника події</b>. Кожен HTML-елемент має JavaScript-події, які спрацьовують в певний момент. Потрібно додати в HTML-елемент атрибут, який задає <b>обробник події</b> - функцію, що викликається у відповідь на подію. В результаті спрацьовування події виконається пов'язаний з нею код. Цей спосіб застосовується в основному для коротких сценаріїв, наприклад, можна встановити зміну кольору фону сторінки при кліці кнопкою миші:</p><pre><code>&lt;script&gt;\n  <b>function</b> changeColor() &#123; <i>// створюємо функцію - обробник події</i>\n    document.body.style.background = \"green\";\n  &#125;\n&lt;/script&gt;\n\n&lt;button <span class=\"color-red\">onclick</span>=\"changeColor();\"&gt; Змінити фон &lt;/button&gt; <i>&lt;!-- призначаємо обробник для події <b>click</b> --&gt;</i></code></pre>"
    },
    {
      "id": "js2",
      "href": "js#js2",
      "title": "Події JavaScript",
      "article": "<p>Для реакції на дії користувача і внутрішньої взаємодії скриптів існують події. <b>Подія</b> - це сигнал від браузера про те, що щось сталося. Найбільш використовувані події:</p><table><tr ><td colspan=\"2\"><h4>Події миші:</h4></td></tr><tr><td>click</td><td>відбувається при кліці на елемент лівою кнопкою миші</td></tr><tr><td>dblclick</td><td>подвійний клік мишки</td></tr><tr><td>mouseover</td><td>виникає, коли на елемент наводиться миша</td></tr><tr><td>mousedown</td><td>виникає, коли  натискається кнопка миші</td></tr><tr><td>mouseup</td><td>виникає, коли відпускається кнопка миші</td></tr><tr><td>mousemove</td><td>відбувається при русі миші</td></tr><tr><td colspan=\"2\"><h4>Події клавіатури:</h4></td></tr><tr><td>keydown</td><td>виникає, коли натискається клавіша</td></tr><tr><td>keyup</td><td>виникає, коли відпускається клавіша</td></tr><tr><td>keypress</td><td>виникає, коли клавіша натиснута і відпущена</td></tr><tr><td colspan=\"2\"><h4>Події на елементах управління:</h4></td></tr><tr><td>submit</td><td>відвідувач відправив форму &lt;form&gt;</td></tr><tr><td>focus</td><td>відвідувач фокусується на елементі, наприклад натискає на &lt;input&gt;</td></tr><tr><td>blur</td><td>відбувається коли елемент форми стає не активним</td></tr><tr><td>change</td><td>відбувається коли значення елемента форми змінюється</td></tr><tr><td colspan=\"2\"><h4>Події вікна браузера:</h4></td></tr><tr><td>load</td><td>у вікно браузера завантажена вся сторінка</td></tr><tr><td>resize</td><td>змінений розмір вікна</td></tr><tr><td>scroll</td><td>запускається, коли використовуються смуги прокрутки</td></tr><tr><td>unload</td><td>виникає при закритті вікна браузера і вивантаженні документа</td></tr></table><br>"
    },
    {
      "id": "js3",
      "href": "js#js3",
      "title": "Змінні в JavaScript",
      "article": "<p>Комп'ютери обробляють інформацію - дані. Дані, що обробляються сценарієм JavaScript, є змінними. <b>Змінні</b> представляють собою іменовані контейнери, що зберігають дані (значення) в пам'яті комп'ютера, які можуть змінюватися в процесі виконання програми. Змінні мають ім'я, тип і значення.<br><b>Ім'я</b> змінної, або ідентифікатор, може включати тільки букви a - z, A - Z, цифри 0 - 9 (цифра не може бути першою в імені змінної), символ $ (може бути тільки першим символом в імені змінної або функції) і символ підкреслення <b>_</b>, наявність пробілів не допускається. Кожна змінна повинна мати власне унікальне ім'я.  Імена змінних в JavaScript чутливі до регістру, що означає, що змінні з іменами <b><i>message</i></b> і <b><i>Message</i></b> - різні змінні. Як ім'я змінної не можна використовувати <u>ключові слова JavaScript.</u><mat-icon class=\"material-icons md-18\" #tooltip=\"matTooltip\" matTooltip=\"Ключові слова - це імена (ідентифікатори), зарезервовані для спеціального використання. Ключові слова мають певне значення в мові JavaScript, так як вони є частиною синтаксису мови. Наприклад: let, null, undefined, if, else\" matTooltipClass=\"tooltip-style\" matTooltipPosition=\"right\">info</mat-icon><br>Створення змінної в JavaScript називається <b>оголошенням</b> змінної. Оголошується змінна за допомогою ключового слова <b>let</b>, за яким слідує ім'я змінної. Оголошувати змінну необхідно перед її використанням.<br>Завантаження значення в змінну (<b>ініціалізація</b>) відбувається за допомогою операції присвоєння <b>=</b></p><pre><code>&lt;script&gt;\n    <b>let</b> message = \"Hello\"; <i>&lt;!-- оголошуємо змінну з іменем <b>message</b> і присвоюємо їй значення - рядок символів <b>\"Hello\"</b> --&gt;</i>\n&lt;/script&gt;</code></pre><p>Змінну можна оголошувати без значення, в цьому випадку їй присвоюється значення за замовчуванням <b>undefined</b>. Значення змінної може змінюватися під час виконання скрипта. Різні змінні можна оголошувати в одному рядку, розділивши їх комою:</p><pre><code>&lt;script&gt;\n    <b>let</b> message = \"Hello\", number_msg = 6, time_msg = 50;\n&lt;/script&gt;</code></pre><p>Для отримання значення створеної раніше змінної необхідно звернутися до її імені.</p>"
    },
    {
      "id": "js4",
      "href": "js#js4",
      "title": "Типи даних",
      "article": "<p>Всі типи даних в JavaScript поділяються на дві групи - прості типи даних (їх також називають примітивними) і складові типи даних (об'єкти). Тип даних змінної залежить від значень, які вона приймає. Тип змінної може змінюватися в процесі здійснення операцій з даними (динамічне приведення типів). Перетворення типів виконується автоматично в залежності від того, в якому контексті вони використовуються.<br><b>Примітивні типи даних:</b></p><table class=\"table\"><tr><td>string</td><td>текстові рядки</td><td>Використовується для зберігання рядка символів, взятих в подвійні або одинарні лапки. Число, взяте в лапки, також є рядком. Рядки можна порівнювати, а також об'єднувати за допомогою операції конкатенації <b>+</b>:<br><b>let</b> str1 = \"Привіт,\";<br><b>let</b> str2 = \" друг\";<br><b>let</b> str3 = str1 + str2; <i>// str3 = \"Привіт, друг\"</i><br>Завдяки автоматичному приведенню типів можна об'єднувати числа і рядки.</td></tr><tr><td>number</td><td>числа</td><td>Використовується для числових значень. Числа в мові JavaScript бувають двох типів: цілі числа (integer) і числа з плаваючою точкою (floating-point number). Числа з плаваючою точкою є числа з дробовою десятковою частиною.<br>Для перетворення рядка в число використовуються <b>parseInt() / parseFloat()</b>. Дані функції по порядку зчитують число з рядка до тих пір поки не виникне помилка:<br>parseInt('100px'); <i>// 100</i><br>parseFloat('12.5em'); <i>// 12.5</i></td></tr><tr><td>boolean</td><td>логічні значення</td><td>Даний тип має два значення: <b>true</b> (істина) або <b>false</b> (фальш). Використовується для порівняння та перевірки умов.</td></tr><tr><td>undefined</td><td>невизначений тип</td><td>Спеціальне значення, означає відсутність первинного значення змінної, а також неіснуючу властивість об'єкта.</td></tr><tr><td>null</td><td>нульовий тип</td><td>Використовується для представлення неіснуючих об'єктів.</td></tr></table><br><p><b>Складові типи даних</b> складаються з більш ніж одного значення. До них відносяться об'єкти (<b>object</b>) і особливі типи об'єктів - масиви (<b>array</b>) і функції (<b>function</b>). Об'єкти містять властивості і методи, масиви являють собою індексований набір елементів, а функції складаються з колекції <u>інструкцій</u> <mat-icon class=\"material-icons md-18\" #tooltip=\"matTooltip\" matTooltip=\"Інструкція - це вказівка на здійснення будь-якої дії, наприклад, створити змінну, запустити цикл, виконати умовну інструкцію, вийти з функції і т. п. Будь-яка програма являє собою послідовність інструкцій. Завершення інструкції в JavaScript позначається символом `;` (крапка з комою).\" matTooltipClass=\"tooltip-style\" matTooltipPosition=\"right\">info</mat-icon>.</p>"
    },
    {
      "id": "js4a",
      "href": "js#js4a",
      "title": "Корисні рядкові методи",
      "article": "<table class=\"table\"><tr><td>str.length</td><td>властивість, яка містить довжину рядка</td><td>str = 'Привіт';<br>console.log(str.length) <i>// 6</i></td></tr><tr><td>str[pos]</td><td>доступ до символів у рядку здійснюється за допомогою квадратних дужок</td><td>str = 'Привіт';<br>console.log(str[0]) <i>// П</i></td></tr><tr><td>toLowerCase()<br>toUpperCase()</td><td>зміна регістру символів</td><td>str = 'Привіт';<br>str.toLowerCase() <i>// привіт</i><br>str.toUpperCase()&nbsp;<i>//&nbsp;ПРИВІТ</i></td></tr><tr><td>str.indexOf(substr,&nbsp;pos)<td>шукає частину рядка substr в рядку str, починаючи з позиції pos, і повертає позицію, на якій розташовується збіг, або -1 при відсутності збігів</td><td>str = 'Привіт, друг';<br>str.indexOf('друг', 0) <i>// 8</i></td></tr><tr><td>str.includes(substr,&nbsp;pos)<td>метод повертає true, якщо в рядку str є підрядок substr, або false, якщо немає</td><td>str = 'Привіт, друг';<br>str.includes('друг', 0) <i>// true</i></td></tr><tr><td>str.startsWith()<br>str.endsWith()<td>методи перевіряють чи починається / закінчується рядок певним рядком</td><td>str = 'Привіт, друг';<br>str.startsWith('друг')&nbsp;<i>//&nbsp;false</i><br>str.endsWith('друг') <i>// true</i></td></tr><tr><td>str.slice(start, end)</td><td>повертає частину рядка від start до (не включаючи) end</td><td>str = 'Привіт, друг!';<br>str.slice(8, 12) <i>// друг</i></td></tr><tr><td>str.trim()</td><td>прибирає пропуски на початку і в кінці рядка</td><td></td></tr></table>"
    },
    {
      "id": "js5",
      "href": "js#js5",
      "title": "Область видимості змінної",
      "article": "<p>Область видимості змінної - це ділянка коду програми, на якій змінні і функції видно і їх можна використовувати. Змінні по області видимості діляться на <b>глобальні</b> та <b>локальні</b>.<br>Змінні, оголошені всередині тіла функції, називаються <b>локальними</b>, їх можна використовувати тільки в цій функції. Локальна змінна створюється кожен раз заново при виконанні функції та знищується при виході з неї (при завершенні роботи функції).<br>Змінні, оголошені всередині елемента &lt;script&gt; за межами всіх функцій називаються <b>глобальними</b>. Глобальна змінна доступна в будь-якому місці коду протягом усього часу, поки сторінка завантажена в браузері. Такі змінні можуть використовуватися всіма функціями, дозволяючи їм обмінюватися даними.</p>"
    },
    {
      "id": "js6",
      "href": "js#js6",
      "title": "Коментарі",
      "article": "<p>Коментарі використовують для пояснення якихось ділянок коду. JavaScript підтримує два види коментарів: однорядковий і багаторядковий.<br>Все, що йде після символів <b>//</b> (два слеша) і до кінця рядка вважається коментарем, такий вид коментаря називається однорядковим.<br>Будь-який текст між символами <b>/ *</b> і <b>* /</b> вважається коментарем, такий вид коментаря називається багаторядковим, так як він може складатися з декількох рядків:</p><pre><code>&lt;script&gt;\n<i><b>//</b> Це однорядковий коментар\n\n<b>/ *</b>\nЦе багатостроковий коментар.\nВін розташований на кількох рядках.\n<b>* /</b></i>\n&lt;/script&gt;</code></pre>"
    },
    {
      "id": "js7",
      "href": "js#js7",
      "title": "Оператори JavaScript",
      "article": "<table class=\"table\"><tr><td colspan=\"2\"><b>Арифметичні оператори</b></td></tr><tr><td> + </td><td>додавання чисел</td></tr><tr><td> - </td><td>віднімання чисел</td></tr><tr><td> * </td><td>множення чисел</td></tr><tr><td> / </td><td>ділення чисел</td></tr><tr><td> % </td><td>обчислює залишок від ділення чисел</td></tr><tr><td> ++ </td><td>інкремент. Збільшує значення на 1 і повертає нове значення</td></tr><tr><td> -- </td><td>декремент. Зменшує значення на 1 і повертає нове значення</td></tr><tr><td colspan=\"2\"><b>Оператори порівняння</b></td></tr><tr><td> < </td><td>менше</td></tr><tr><td> <= </td><td>менше або дорівнює</td></tr><tr><td> > </td><td>більше</td></tr><tr><td> >= </td><td>більше або дорівнює</td></tr><tr><td> == </td><td>дорівнює</td></tr><tr><td> != </td><td>не дорівнює</td></tr><tr><td> === </td><td>строго дорівнює. Здійснює порівняння значень операндів без перетворення типів</td></tr><tr><td> !== </td><td>строго не дорівнює. Здійснює порівняння значень операндів без перетворення типів</td></tr><tr><td colspan=\"2\"><b>Логічні оператори</b></td></tr><tr><td> && </td><td>логічне І</td></tr><tr><td> || </td><td>логічне АБО</td></tr><tr><td> ! </td><td>логічне НЕ</td></tr></table>"
    },
    {
      "id": "js8",
      "href": "js#js8",
      "title": "Взаємодія з користувачем",
      "article": "<p>Використання вбудованих функцій взаємодії з користувачем браузера - найпростіший спосіб вивести повідомлення або отримати інформацію від відвідувача. Конкретне місце, де виводиться вікно з питанням - зазвичай це центр браузера, і зовнішній вигляд вікна вибирає браузер. Розробник не може на це впливати.</p><table class=\"table\"><tr><td><b>alert(\"Текст повідомлення\");</b><i> // вікно повідомлення</i><br>виводить на екран <u>модальне</u> <mat-icon class=\"material-icons md-18\" #tooltip=\"matTooltip\" matTooltip=\"Слово «модальне» означає, що відвідувач не може взаємодіяти зі сторінкою, натискати інші кнопки і т.п., поки не закриє вікно.\" matTooltipClass=\"tooltip-style\" matTooltipPosition=\"right\">info</mat-icon> вікно з повідомленням і призупиняє виконання скрипта, поки користувач не натисне <b>ОК</b>.</td></tr><tr><td><b>result&nbsp;=&nbsp;prompt(\"Текст&nbsp;запиту\",&nbsp;\"Рядок&nbsp;за&nbsp;замовчуванням\");</b><i> // вікно запиту</i><br><br>Виводить модальне вікно з текстом запиту, полем для введення тексту, яке заповнене рядком за замовчуванням і кнопками <b>OK / CANCEL</b>. Користувач повинен або щось ввести і натиснути <b>OK</b>, або скасувати введення кліком на <b>CANCEL</b> (або <b>Esc</b> на клавіатурі). Результатом буде рядок, який ввів користувач або спеціальне значення <b>null</b>, якщо введення було скасоване.</td></tr><tr><td><b>result&nbsp;=&nbsp;confirm(\"Текст запитання\");</b><i> // вікно підтвердження</i><br><br>Виводить модальне вікно з запитанням та двома кнопками: <b>OK</b> і <b>CANCEL</b>. Результатом буде <b>true</b> при натисканні <b>OK</b> і <b>false</b> - при натисканні <b>CANCEL (Esc)</b>.</td></tr></table><pre><code>&lt;script&gt;\n  <b>let</b> name = prompt( \"Як Вас звати?\", \"Введіть ім'я\"); <i>//оголошуєм змінну name. Виводим вікно запиту</i>\n  alert( \"Привіт, \" + name); <i>//виводим повідомлення, використовуючи операцію конкатенації</i>\n  <b>let</b> answer = confirm( \"Продовжимо? \\n Натисніть ОК. Якщо ні, то натисніть Cancel.\"); <i>//оголошуєм змінну answer. Виводим вікно підтвердження</i>\n  <b>if</b> (answer == <b>true</b>) &#123; <i>//якщо користувач натиснув OK - виводим повідомлення:</i>\n    alert ( \"Ура!\");\n  &#125; <b>else</b> &#123; <i>//якщо користувач натиснув Cancel - виводим повідомлення:</i>\n    alert ( \"До побачення\");\n  &#125;\n&lt;/script&gt;</code></pre>"
    },
    {
      "id": "js9",
      "href": "js#js9",
      "title": "Умовний оператор if",
      "article": "<p>Іноді нам потрібно виконати різні дії в залежності від умов. Для цього ми  використовуємо оператор <b>if</b>. Оператор <b>if</b> може містити необов'язковий блок <b>else</b> (інакше). Виконується, коли умова помилкова. У випадку, коли потрібно перевірити кілька варіантів умови, використовується блок <b>else if</b>. Умовний оператор має наступний синтаксис:</p><pre><code>  <b>if</b> ( умова 1 ) &#123; <i>//оператор <b>if</b> обчислює умову в дужках і, якщо результат <b>true</b>, виконує блок коду.\n    //код, який виконується якщо виконується умова 1</i>\n  &#125; <b>else if</b> ( умова 2 ) &#123;\n    <i>//код, який виконується якщо виконується умова 2</i>\n  &#125; <b>else</b> &#123;\n    <i>//код, який виконується якщо жодна умова не виконується</i>\n  &#125;</code></pre>"
    },
    {
      "id": "js10",
      "href": "js#js10",
      "title": "Цикли while і for",
      "article": "<p>При написанні скриптів часто виникає завдання зробити однотипну дію багато разів. Для багаторазового повторення однієї ділянки коду передбачені цикли <b>while</b> і <b>for</b>.</p><p>&bull; Цикл <b>while</b> має наступний синтаксис:</p><pre><code>  <b>while</b> ( умова ) &#123;\n    <i>//код (тіло циклу) виконується, поки умова істинна</i>\n   <i> //одне виконання тіла циклу називається ітерація</i>\n  &#125;</code></pre><p>Наприклад, цикл нижче виводить <b>i</b>, поки <b>i</b> < 3:</p><pre><code>  <b>let</b> i = 0;\n  <b>while</b> ( i < 3 ) &#123; <i>//цей цикл робить три ітерації</i>\n    alert(i);\n    i++; <i>//якби цей рядок був відсутній, то цикл повторювався б (в теорії) вічно</i>\n  &#125;</code></pre><p>&bull; Цикл <b>for</b> має наступний синтаксис:</p><pre><code>  <b>for</b> ( ініціалізація; умова; крок ) &#123;\n    <i>//код (тіло циклу)</i>\n  &#125;</code></pre><p>Цикл нижче виконує alert( i ) для <b>i</b> від <b>0</b> до (але не включаючи) <b>3</b>:</p><pre><code>  <b>for</b> (<b>let</b> i = 0; i < 3; i++) &#123;\n    alert(i);\n  &#125;</code></pre><table class=\"table\"><tr><td>ініціалізація</td><td>i = 0</td><td>Виконується один раз при вході в цикл</td></tr><tr><td>умова</td><td>i < 3</td><td>Перевіряється перед кожною ітерацією циклу. Якщо обчислиться в false, цикл зупиниться</td></tr><tr><td>крок</td><td>i++</td><td>Виконується після тіла циклу на кожній ітерації перед перевіркою умови</td></tr><tr><td>тіло циклу</td><td>alert(&nbsp;i&nbsp;);</td><td>Виконується знову і знову, поки умова обчислюється в true.</td></tr></table>"
    },
    {
      "id": "js11",
      "href": "js#js11",
      "title": "Функції (functions)",
      "article": "<p>Функції є одним з найбільш важливих будівельних блоків коду в JavaScript. Функції складаються з набору інструкцій і зазвичай виконують якусь одну певну задачу або ж проводять ті чи інші обрахунки. Головна мета створення функцій: позбавлення коду від дублювання. Створивши функцію один раз, її можна запускати знову і знову. Кожна функція на сторінці повинна мати унікальне ім'я. Ім'я функції має бути задано латинськими літерами і не має починатися з цифр. Імена функцій в JavaScript чутливі до регістру. Код поміщений в функцію буде виконано тільки після явного виклику цієї функції. Для виклику функції необхідно вказати її ім'я, за яким слідують дві дужки.</p><pre><code><b>function</b> showMessage() &#123; <i>/* оголошується функція за допомогою ключового слова <b>function</b>,<br>                           за ним йде ім'я з двома дужками після нього (), далі - дві фігурні дужки &#123;&#125;*/</i>\n  alert(\"Hello\"); <i>// усередині фігурних дужок міститься код, який запускається кожен раз при виклику функції</i>\n&#125;\n\nshowMessage(); <i>// оголошена функція доступна по імені</i></code></pre><p>Всередину функції можна передавати дані - аргументи. Аргументи можуть бути змінними або значеннями. У кожну функцію може бути передано необмежену кількість аргументів.</p><pre><code><b>function</b> showMessage(name, message) &#123; <i>// аргументами функції <b>showMessage</b> є <b>name</b> і <b>message</b></i>\n  alert(name + \" : \" + message);\n&#125;\n\n<b>let</b> sender = \"Вася\";\nshowMessage(sender, \"Привіт\"); <i>// \"Вася : Привіт\"</i>\nshowMessage(\"Вася\", \"Як справи?\"); <i>// \"Вася : Як справи?\"</i></code></pre><p>Функція може повернути результат, який буде переданий в код, який її викликав. Для повернення значення використовується команда <b>return</b>.</p><pre><code><b>function</b> calcTime(speed, distance) &#123;\n  <b>let</b> timeResult = distance / speed;\n  <b>return</b> timeResult;\n}\n\n<b>let</b> time = calcTime(1200, 60);</code></pre><p>Змінні, оголошені всередині функції, доступні тільки всередині цієї функції. Такі змінні називаються <b>локальними</b>. Змінні, оголошені зовні всіх функцій, видимі для будь-якої функції (якщо тільки їх не перекривають однойменні локальні змінні) і називаються <b>глобальними</b>.</p><p>Функція може бути створена як частина виразу:</p><pre><code><b>let</b> calcTime = <b>function</b>(speed, distance) &#123;\n  <b>let</b> timeResult = distance / speed;\n  <b>return</b> timeResult;\n}\n\n<b>let</b> time = calcTime(1200, 60);</code></pre>"
    },
    {
      "id": "js12",
      "href": "js#js12",
      "title": "Об'єкти (object)",
      "article": "<p>Об'єкти використовуються для зберігання колекцій різних значень і більш складних сутностей. Об'єкт - це набір <b>властивостей</b>, кожна властивість - це пара «ключ: значення», де ключ - це рядок (ім'я властивості), а значення може бути чим завгодно. Властивості об'єкта в основному такі ж, як і звичайні змінні JavaScript, за винятком того, що вони прикріплені до об'єкта. Властивості об'єкта визначають його характеристики. Доступ до властивості здійснюється по імені. Для доступу до властивості об'єкта використовується оператор доступу <b>.</b> (точка). Альтернативний спосіб доступу до властивостей - квадратні дужки <b>[ ]</b>.<br>Значенням властивості може бути функція. Властивість, значенням якої є функція, називається <b>методом</b>. Виклик методу здійснюється так, як і виклик звичайної функції - за допомогою оператора <b>()</b>. Методи є діями, які можуть бути здійснені над об'єктами.<br>Як правило, методу об'єкта необхідний доступ до інформації, яка зберігається в цьому об'єкті, щоб виконати з нею будь-які дії (відповідно до призначення методу). Для доступу до інформації всередині об'єкта метод використовує ключове слово <b>this</b>.<br>Об'єкт може бути створений за допомогою фігурних дужок <b>&#123; }</b>:</p><pre><code><i>// Створення порожнього об'єкта</i>\n<b>let</b> person = &#123;&#125;; <i>// створення об'єкта починається з визначення та ініціалізації змінної</i>\n\n<i>// Створення об'єкта з властивостями і методами</i>\n<b>let</b> person = &#123;\n  name: 'Вася',  <i>// - властивість об'єкта <b>name</b> зі значенням 'Вася'</i>\n  age: 12,  <i>// - властивість об'єкта <b>age</b> зі значенням 12</i>\n  interests: ['музика', 'гірські лижі'],  <i>// - властивість об'єкта <b>interests</b>, значенням якої є масив</i>\n\n  info: <b>function</b>() &#123; <i>// метод <b>info</b> виводить у вікно інформацію про об'єкт використовуючи властивості цього об'єкта</i>\n    alert(<b>this</b>.name + ', ' + <b>this</b>.age + ' років. Інтереси: ' + <b>this</b>.interests[0] + ' і ' + <b>this</b>.interests[1] + '.');\n  &#125;, <i>// для доступу до поточного об'єкту з методу використовується ключове слово <b>this</b></i>\n\n  greeting() &#123; <i>// створення методу <b>greeting</b>, короткий синтаксис для методів</i>\n    alert('Привіт! Я ' + <b>this</b>.name + '.');\n  &#125;\n&#125;; <i>// крапка з комою після закриваючої фігурної дужки!</i>\n\nalert(person.name); <i>// доступ до властивості <b>name</b> об'єкта <b>person</b> (отримаємо: \"Вася\")</i>\nperson.info(); <i>// доступ до метода об'єкта (отримаємо: Вася, 12 років. Интереси: музика і гірські лижі.</i></code></pre>"
    },
    {
      "id": "js13",
      "href": "js#js13",
      "title": "Цикл for..in",
      "article": "<p>Для перебору всіх властивостей об'єкта використовується цикл <b>for ... in</b>. Цикл for...in має наступний синтаксис:</p><pre><code>  <b>for</b> ( key <b>in</b> object ) &#123;\n    <i>//тіло циклу виконується для кожної властивості об'єкта</i>\n  &#125;</code></pre><p>Наприклад, цикл нижче виводить всі властивості ( ім'я кожної властивості та її значення ) об'єкта user:</p><pre><code><b>let</b> user = &#123;\n  name: \"Вася\",\n  age: 15,\n  isAdmin: true\n&#125;;\n\n<b>for</b> (<b>let</b> key <b>in</b> user) &#123;\n  <i>//ключі</i>\n  console.log( key ); <i>//виведе: name, age, isAdmin</i>\n  <i>//значення ключів</i>\n  console.log( user[key] ); <i>//виведе: Вася, 15, true</i>\n&#125;</code></pre>"
    },
    {
      "id": "js14",
      "href": "js#js14",
      "title": "Об'єкт Math",
      "article": "<p>Для обчислення математичних функцій використовується JavaScript-об'єкт <b>Math.</b> Об'єкт Math є вбудованим об'єктом, що зберігає в своїх властивостях і методах різні математичні константи і функції:</p><table class=\"table\"><tr><td>Math.ceil(x)</td><td>Повертає найменше ціле число, більше, або дорівнює зазначеному числу (заокруглення до цілого в більшу сторону)</td></tr><tr><td>Math.floor(x)</td><td>Повертає найбільше ціле число, менше, або дорівнює зазначеному числу (заокруглення до цілого в меншу сторону)</td></tr><tr><td>Math.round(x)</td><td>Повертає значення числа, округлене до найближчого цілого</td></tr><tr><td>Math.max(x,&nbsp;y,&nbsp;z,&nbsp;...)</td><td>Повертає найбільше число зі своїх аргументів</td></tr><tr><td>Math.min(x,&nbsp;y,&nbsp;z,&nbsp;...)</td><td>Повертає найменше число зі своїх аргументів</td></tr><tr><td>Math.random()</td><td>Повертає випадкове число в діапазоні від 0 до 1</td></tr><tr><td>Math.pow(x, y)</td><td>Підносить число x в степінь y</td></tr><tr><td>Math.sqrt(x)</td><td>Повертає квадратний корінь числа</td></tr><tr><td>Math.PI</td><td>Число &#960; (приблизно дорівнює 3,14159)</td></tr></table>"
    },
    {
      "id": "js15",
      "href": "js#js15",
      "title": "Об'єкт document. Document Object Model",
      "article": "<p>На додаток до базового функціоналу JavaScript, браузери надають свої об'єкти і додаткові функції для управління веб-сторінками. Для отримання, зміни або додавання вмісту в HTML-документ і для обробки подій в цьому документі використовується об'єкт <b>document</b>.</p><p>Основою HTML-документа є теги. Відповідно до об'єктної моделі документа (<b>Document Object Model</b>, скорочено - DOM), кожен HTML-тег є об'єктом. DOM представляє вміст сторінки у вигляді об'єктів. Всі ці об'єкти доступні за допомогою JavaScript і можуть бути використані для зміни сторінки. Об'єкт <b>document</b> представляє весь HTML-документ. З нього можна отримати доступ до будь-якого елемента. Кожна веб-сторінка, що завантажується в браузері, має свій власний об'єкт document.</p><table class=\"table\"><tr><td colspan=\"2\"><b>Пошук елементів на сторінці</b></td></tr><tr><td>document.getElementById(id)</td><td>повертає посилання на елемент з зазначеним id, якщо у елемента є атрибут id. У документі може бути тільки один елемент з даними id.</td></tr><tr><td>element.getElementsByClassName(className)</td><td>повертає колекцію елементів, які відповідають зазначеному класу</td></tr><tr><td>element.getElementsByTagName(tag)</td><td>повертає колекцію елементів з данним тегом</td></tr><tr><td>element.querySelector(css)</td><td>повертає перший елемент, який відповідає даному CSS-селектору</td></tr><tr><td>element.querySelectorAll(css)</td><td>самий універсальний метод пошуку. Повертає всі елементи всередині element, що задовольняють даному CSS-селектору</td></tr><tr><td colspan=\"2\"><b>Властивості DOM-елементів</b></td></tr><tr><td>document.body</td><td>відповідає тегу &lt;body&gt; </td></tr><tr><td>element.tagName</td><td>ім'я тега DOM-елемента</td></tr><tr><td>element.innerHTML</td><td>дозволяє отримати / змінити HTML-вміст елемента</td></tr><tr><td>element.textContent</td><td>надає доступ до тексту всередині елемента</td></tr><tr><td>element.hidden = true / false</td><td>коли значення встановлено в true, робить те ж саме, що і CSS display: none</td></tr><tr><td colspan=\"2\"><b>Більшість стандартних HTML-атрибутів мають відповідні властивості DOM:</b></td></tr><tr><td>element.id</td><td>значення атрибута id</td></tr><tr><td>element.value</td><td>значення для &lt;input&gt;, &lt;select&gt; і &lt;textarea&gt;</td></tr><tr><td>element.href</td><td>адреса посилання для &lt;a&gt;</td></tr><tr><td colspan=\"2\"><b>Методи доступу до атрибутів HTML-тегів</b></td></tr><tr><td>element.hasAttribute(name)</td><td>перевіряє наявність атрибута</td></tr><tr><td>element.getAttribute(name)</td><td>отримує значення атрибута</td></tr><tr><td>element.setAttribute(name, value)</td><td>встановлює значення атрибута</td></tr><tr><td>element.removeAttribute(name)</td><td>видаляє атрибут</td></tr><tr><td colspan=\"2\"><b>Зміна вмісту HTML-документа</b></td></tr><tr><td>document.createElement(tag)</td><td>створює новий елемент із заданим тегом</td></tr><tr><td>element.append(newElement)</td><td>додає newElement або рядок в кінець element</td></tr><tr><td>element.prepend(newElement)</td><td>вставляє newElement або рядок в початок element</td></tr><tr><td>element.before(newElement)</td><td>вставляє newElement або рядок перед element</td></tr><tr><td>element.after(newElement)</td><td>вставляє newElement або рядок після element</td></tr><tr><td>element.replaceWith(newElement)</td><td>замінює element заданими newElement або рядком</td></tr><tr><td>element.remove()</td><td>видалення елемента</td></tr><tr><td>element.cloneNode(true)</td><td>клонування елемента з усіма атрибутами і дочірніми елементами.</td></tr><tr><td>element.cloneNode(false)</td><td>клонування елемента без дочірніх елементів.</td></tr><tr><td colspan=\"2\"><b>Стилі і класи</b></td></tr><tr><td>element.classList.add(\"class\")</td><td>додати клас</td></tr><tr><td>element.classList.remove(\"class\")</td><td>видалити клас</td></tr><tr><td>element.classList.toggle(\"class\")</td><td>додати клас, якщо його немає, інакше видалити</td></tr><tr><td>element.classList.contains(\"class\")</td><td>перевірка наявності класу, повертає true / false</td></tr><tr><td>element.style</td><td>об'єкт зі стилями в форматі camelCase</td></tr><tr><td colspan=\"2\"><b>Геометричні властивості елементів</b></td></tr><tr><td>element.offsetLeft / offsetTop</td><td>позиція в пікселях верхнього лівого кута щодо батьківського елемента</td></tr><tr><td>element.offsetWidth / offsetHeight</td><td>ширина / висота елемента, включаючи рамки</td></tr><tr><td>element.clientLeft / clientTop</td><td>відстань від верхнього лівого зовнішнього кута до внутрішнього</td></tr><tr><td>element.clientWidth / clientHeight</td><td>ширина / висота вмісту разом з внутрішніми відступами padding</td></tr></table><br><p>Для перебору колекції елементів використовується цикл <b>for...of</b>:</p><pre><code>  <b>let</b> allDiv = document.body.getElementsByTagName('div'); <i>// знайде всі елементи &lt;div&gt; на сторінці</i>\n  <b>for</b> (<b>let</b> element <b>of</b> allDiv) &#123;\n    console.log(element); <i>// виведе знайдені &lt;div&gt;</i>\n  &#125;</code></pre>"
    },
    {
      "id": "js16",
      "href": "js#js16",
      "title": "Обробники подій. Об'єкт події",
      "article": "<p>Для того, щоб JavaScript-код реагував на подію - потрібно призначити обробник, тобто функцію, яка спрацює, як тільки подія відбудеться. Обробник може бути призначений в атрибуті HTML-елемента \"on + ім'я події\" (наприклад: onclick) або використовуючи властивість DOM-елемента \"on + ім'я події\" (наприклад: element.onclick).</p><pre><code>&lt;script&gt;\n  window.onload = <b>function()</b> &#123; <i>// завантаження документа</i>\n    document.body.onmousemove = <b>function()</b> &#123; <i>// відбувається переміщення курсора миші на елементі <b>body</b></i>\n      document.body.style.backgroundColor = 'aqua'; <i>// при русі миші міняється колір фону елемента <b>body</b></i>\n    &#125;\n  &#125;\n&lt;/script&gt;</code></pre><p>Альтернативний спосіб призначення обробників - за допомогою спеціальних методів:</p><table class=\"table\"><tr><td>element.addEventListener(event, handler)</td><td>дозволяє встановити обробник події для елемента<br>event - ім'я події, наприклад click<br>handler - посилання на функцію-обробник</td></tr><tr><td>element.removeEventListener(event,&nbsp;handler)</td><td>видаляє обробник події, який був встановлений методом addEventListener()</td></tr></table><pre><code>&lt;script&gt;\n  window.onload = <b>function()</b> &#123; <i>// завантаження документа</i>\n    elementDiv = document.getElementById(\"divid\"); <i>// знаходимо елемент по id</i>\n    elementDiv.addEventListener('click', function() &#123; <i>// призначаємо обробник для події click</i>\n      document.body.style.backgroundColor = 'silver';\n      <i>// всередині обробника події <b>this</b> посилається на поточний елемент (на якому призначений обробник)</i>\n      <b>this</b>.style.backgroundColor = \"blue\";\n    &#125;);\n  &#125;\n&lt;/script&gt;</code></pre><p>При обробці події, можуть знадобитися деталі: координати курсору, введений символ і інші, в залежності від події. Деталі події браузер записує в об'єкт події <b>event</b>, який передається аргументом в обробник.</p><pre><code>  document.body.onclick = <b>function</b>(event) &#123; <i>// відбувається подія <b>click</b> на елементі <b>body</b></i>\n    alert(event.type + \" на \" + event.currentTarget); <i>// виводиться тип події і елемент, на якому подія відбулась</i>\n    alert(event.clientX + \":\" + event.clientY); <i>// виводяться координати кліка</i>\n  &#125;</code></pre><p><b>Властивості і методи об'єкта event</b> (в залежності від події, у об'єкта події є і інші властивості):</p><table class=\"table\"><tr><td>event.type</td><td>тип події</td></tr><tr><td>event.currentTarget</td><td>елемент, на якому спрацював призначений обробник події</td></tr><tr><td>event.target</td><td>цільовий елемент, на якому відбулася подія</td></tr><tr><td>event.clientX<br>event.clientY</td><td>координати курсора в момент кліка (відносно вікна браузера)</td></tr><tr><td>event.preventDefault()</td><td>деякі події автоматично викликають певні дії браузера. Якщо подія обробляється виключно за допомогою JavaScript, дію браузера за замовчуванням можна скасувати</td></tr></table>"
    },
    {
      "id": "js17",
      "href": "js#js17",
      "title": "Масиви",
      "article": "<p><b>Масив</b> - це впорядкована колекція значень, де дані зберігаються за номерами. Масиви в мові JavaScript є спеціалізованою формою об'єктів. Значення в масиві називаються <b>елементами</b>, кожен елемент характеризується числовою позицією в масиві, яка називається <b>індексом</b>. Елементи масиву можуть мати будь-який тип, різні елементи одного і того ж масиву можуть мати різні типи. Елементи масиву можуть бути об'єктами або іншими масивами, що дозволяє створювати складні структури даних, такі як масиви об'єктів і масиви масивів.</p><p>Відлік індексів елементів масиву в мові JavaScript починається з <b>нуля</b> і для них використовуються цілі числа - перший елемент масиву має індекс 0. Масиви в JavaScript є динамічними: вони можуть збільшуватися і зменшуватися в розмірах у міру необхідності.</p><p>Створити масив можна  за допомогою оператора <b>[ ]</b>:</p><pre><code><b>let</b> empty = []; <i>// створення порожнього масиву</i>\n<b>let</b> numbers = [2, 3, 5, 7, 11]; <i>// масив з числовими елементами. Початкові значення елементів можна вказувати при створенні</i></code></pre><p>Отримати елемент можна вказавши його індекс у квадратних дужках <b>[ ]</b>. Цей синтаксис придатний як для читання, так і для запису значення елемента масиву:</p><pre><code><b>let</b> users = [\"Том\", \"Джек\", \"Алекс\"]; <i>// масив з рядковими елементами</i>\nconsole.log(users[1]); <i>// Джек</i>\nusers[3] = \"Іван\"; <i>// додано елемент в кінець масиву</i>\nusers[1] = \"Пітер\"; <i>// замінено другий елемент масиву</i>\nconsole.log(users); <i>// [\"Том\", \"Пітер\", \"Алекс\", \"Іван\"]</i>\nconsole.log(users[1]); <i>// Пітер</i></code></pre><p>Загальна кількість елементів масиву міститься в його властивості <b>length</b>. Індекс останнього елемента дорівнює значенню властивості length мінус 1:</p><pre><code>console.log(users.length); <i>// 4</i>\nusers[users.length] = \"Джон\"; <i>// додано елемент в кінець масиву</i></code></pre><h4>Перебір елементів масиву</h4><p> &bull; Цикл <b>for</b> по цифровим індексам:</p><pre><code><b>let</b> array = [\"елемент 1\", \"елемент 2\", \"елемент 3\"];\n\nfor (<b>let</b> i = 0; i < array.length; i++) &#123;\n  console.log(array[i]);\n&#125;</code></pre><p> &bull; Цикл <b>for..of</b> по значенням:</p><pre><code><b>for</b> (<b>let</b> element <b>of</b> array) &#123;\n  console.log(element);\n&#125;</code></pre><h4>Методи масивів</h4><table class=\"table\"><tr><td>array.push(element)</td><td>додає елементи в кінець масиву</td></tr><tr><td>array.pop()</td><td>вилучає елемент з кінця масиву</td></tr><tr><td>array.indexOf(element,&nbsp;from)</td><td>пошук в масиві. Шукає element, починаючи з індексу from, і повертає індекс, на якому був знайдений element, в іншому випадку -1</td></tr><tr><td colspan=\"2\" class=\"td-code\"><b>let</b> users = [\"Том\", \"Джек\", \"Алекс\"];<br><br>console.log(users.indexOf(\"Джек\")); <i>// 1</i><br>console.log(users.indexOf(\"Мері\")); <i>// -1</i></td></tr><tr><td>array.find(function(item) &#123; &#125;)</td><td>шукає елемент, який задовольняє умові перевіряючої функції і повертає його (або undefined, якщо таке значення не знайдено)</td></tr><tr><td colspan=\"2\" class=\"td-code\"><b>let</b> users = [ &#123;id: 1, name: \"Том\"&#125;, &#123;id: 2, name: \"Джек\"&#125;, &#123;id: 3, name: \"Алекс\"&#125; ];<br><br><b>let</b> user = users.find(<b>function</b>(item) &#123; <i>// функція викликається по черзі для кожного елемента масиву</i><br>&nbsp;&nbsp;<b>if</b> (item.id == 1) &#123; <i>// item - черговий елемент</i><br>&nbsp;&nbsp;&nbsp;&nbsp;<b>return true</b>; <i>// якщо функція повертає true, пошук переривається і повертається item</i><br>&nbsp;&nbsp;&#125;<br>&#125;);<br><br>console.log(user.name); <i>// Том</i></td></tr><tr><td>array.filter(function(item) &#123; &#125;)</td><td>повертає масив елементів, які задовольняють умові перевіряючої функції. У випадку, якщо нічого не знайдено - повертається порожній масив</td></tr><tr><td colspan=\"2\" class=\"td-code\"><b>let</b> users = [ &#123;id: 1, name: \"Том\"&#125;, &#123;id: 2, name: \"Джек\"&#125;, &#123;id: 3, name: \"Алекс\"&#125; ];<br><br><b>let</b> firstTwo = users.filter(<b>function</b>(item) &#123;<br>&nbsp;&nbsp;<b>if</b> (item.id < 3) &#123;<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>return true</b>; <i>// якщо функція повертає true, елемент додається до результату, і перебір триває</i><br>&nbsp;&nbsp;&#125;<br>&#125;);<br><br>console.log(firstTwo.length); // 2</td></tr><tr><td>array.fill(value, start, end)</td><td>заповнює масив значеннями value, починаючи з індексу start до end.</td></tr><tr><td colspan=\"2\" class=\"td-code\"><b>let</b> numbers = [16, 17, 22, 25];<br>numbers.fill(\"15\", 1, 3);<br>console.log(numbers); <i>// [16, \"15\", \"15\", 25]</i><br>numbers.fill(20);<br>console.log(numbers); <i>// [20, 20, 20, 20]</i></td></tr></table>"
    },
    {
      "id": "js18",
      "href": "js#js18",
      "title": "Планування виклику функцій",
      "article": "<p>Якщо необхідно виконати функцію не в даний момент, а через заданий інтервал часу, використовуються методи <b>setTimeout</b> і <b>setInterval</b>.</p><table class=\"table\"><tr><th>Метод</th><th>Пояснення</th><th colspan=\"2\">Параметри</th></tr><tr><td rowspan=\"2\">setTimeout(function,&nbsp;ms)</td><td rowspan=\"2\">дозволяє викликати функцію один раз через певний інтервал часу. Метод повертається цифрове значення - timerId, що використовується для ідентифікації створеного таймера</td><td>function</td><td>функція, яка буде виконана</td></tr><tr><td>ms</td><td>затримка перед запуском в мілісекундах (1000&nbsp;мс&nbsp;=&nbsp;1&nbsp;с)</td></tr><tr><td>clearTimeout(timerId)</td><td>якщо функція ще не була виконана, зупиняє її виконання</td><td>timerId</td><td>ідентифікатор таймера, створеного setTimeout()</td></tr><tr><td colspan=\"4\" class=\"td-code\"><b>function</b> showMessage() &#123;<br>&nbsp;&nbsp;alert(\"Повідомлення з затримкою\");<br>&#125;<br><i> // <b>Важливо!</b> - передаємо функцію, але не запускаємо її: не додаємо дужки () після імені функції</i><br><b>let</b> timerId = setTimeout(showMessage, 1000); <i> // заплановано виклик функції showMessage() через одну секунду.</i><br>clearTimeout(timerId); <i> // скасовуємо виклик функції showMessage(). В результаті нічого не відбувається</i></td></tr><tr><td rowspan=\"2\">setInterval(function, ms)</td><td rowspan=\"2\">дозволяє викликати функцію регулярно, повторюючи виклик через певний інтервал часу. Метод повертається цифрове значення - timerId, що використовується для ідентифікації створеного таймера</td><td>function</td><td>функція, яка буде виконуватись</td></tr><tr><td>ms</td><td>затримка перед наступним запуском в мілісекундах</td></tr><tr><td>clearInterval(timerId)</td><td>зупиняє подальше виконання функції</td><td>timerId</td><td>ідентифікатор таймера</td></tr><tr><td colspan=\"4\" class=\"td-code\"><b>let</b> timerId = setInterval(showMessage, 2000); <i> // викликається функція showMessage() кожні 2 секунди</i><br>setTimeout(<b>function</b>()&#123; clearInterval(timerId); &#125;, 5000); <i> // припиняються виклики showMessage() через 5 секунд</i></td></tr></table>"
    },
    {
      "id": "js19",
      "href": "js#js19",
      "title": "HTML5 Canvas 2d API",
      "article": "content coming soon"
    }
  ]
}
